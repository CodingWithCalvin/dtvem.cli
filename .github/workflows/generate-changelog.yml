name: Generate Changelog

on:
  workflow_call:
    outputs:
      changelog:
        description: "The generated changelog content"
        value: ${{ jobs.generate.outputs.changelog }}

jobs:
  generate:
    name: Generate Changelog
    runs-on: ubuntu-latest
    outputs:
      changelog: ${{ steps.changelog.outputs.CHANGELOG }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for changelog generation

    - name: Generate changelog
      id: changelog
      run: |
        # Get previous release tag
        # NOTE: This must run BEFORE creating the new tag, otherwise git describe
        # will find the new tag and the changelog will be empty
        PREVIOUS_TAG=$(git describe --abbrev=0 --tags --match "v*" 2>/dev/null || echo "")

        echo "Previous tag: ${PREVIOUS_TAG:-'(none - first release)'}"

        # Get commit data since last release
        if [ -z "$PREVIOUS_TAG" ]; then
          COMMIT_RANGE="HEAD"
        else
          COMMIT_RANGE="${PREVIOUS_TAG}..HEAD"
        fi

        # Collect highlights from PR comments and categorize commits
        # Each category stores entries with issue number prefix for sorting: "NNNN|entry"
        declare -a HIGHLIGHTS
        declare -a BUGS           # fix
        declare -a IMPROVEMENTS   # perf, refactor
        declare -a FEATURES       # feat
        declare -a MAINTENANCE    # docs, style, test, build, ci, chore
        declare -a OTHER          # anything else (except revert which is omitted)

        # Process each commit
        while IFS= read -r line; do
          [ -z "$line" ] && continue

          SHA=$(echo "$line" | cut -d'|' -f1)
          SUBJECT=$(echo "$line" | cut -d'|' -f2)
          SHORT_SHA=$(echo "$line" | cut -d'|' -f3)
          BODY=$(echo "$line" | cut -d'|' -f4-)

          echo "Processing commit: $SHA"

          # Skip revert commits
          if echo "$SUBJECT" | grep -qE "^revert(\(|:)"; then
            echo "  Skipping revert commit"
            continue
          fi

          # Check for PR and /release-note comments
          PR_DATA=$(gh pr list --search "$SHA" --state merged --json number --limit 1 2>/dev/null || echo "[]")
          if [ "$PR_DATA" != "[]" ] && [ -n "$PR_DATA" ]; then
            PR_NUMBER=$(echo "$PR_DATA" | jq -r '.[0].number // empty')
            if [ -n "$PR_NUMBER" ]; then
              echo "  Found PR #$PR_NUMBER"

              # Check for /release-note in PR comments
              PR_COMMENTS=$(gh pr view "$PR_NUMBER" --json comments --jq '.comments[].body' 2>/dev/null || echo "")
              RELEASE_NOTE=$(echo "$PR_COMMENTS" | grep "^/release-note " | sed 's|^/release-note ||' | head -1 || echo "")
              if [ -n "$RELEASE_NOTE" ]; then
                echo "  Found /release-note: $RELEASE_NOTE"
                HIGHLIGHTS+=("$RELEASE_NOTE")
              fi
            fi
          fi

          # Extract issue number from commit body for sorting
          ISSUE_NUM=$(echo "$BODY" | grep -oiE "(fixes|closes|resolves)\s*#[0-9]+" | grep -oE "[0-9]+" | head -1 || echo "99999")
          ISSUE_REF=$(echo "$BODY" | grep -oiE "(fixes|closes|resolves)\s*#[0-9]+" | head -1 || echo "")

          # Build commit entry
          if [ -n "$ISSUE_NUM" ] && [ "$ISSUE_NUM" != "99999" ]; then
            ENTRY="- #${ISSUE_NUM} - $SUBJECT ($SHORT_SHA)"
          else
            ENTRY="- $SUBJECT ($SHORT_SHA)"
          fi

          # Store with issue number prefix for sorting
          SORTABLE_ENTRY="${ISSUE_NUM}|${ENTRY}"

          # Categorize by conventional commit prefix
          if echo "$SUBJECT" | grep -qE "^fix(\(|:)"; then
            BUGS+=("$SORTABLE_ENTRY")
          elif echo "$SUBJECT" | grep -qE "^(perf|refactor)(\(|:)"; then
            IMPROVEMENTS+=("$SORTABLE_ENTRY")
          elif echo "$SUBJECT" | grep -qE "^feat(\(|:)"; then
            FEATURES+=("$SORTABLE_ENTRY")
          elif echo "$SUBJECT" | grep -qE "^(docs|style|test|build|ci|chore)(\(|:)"; then
            MAINTENANCE+=("$SORTABLE_ENTRY")
          else
            OTHER+=("$SORTABLE_ENTRY")
          fi
        done < <(git log ${COMMIT_RANGE} --pretty=format:"%H|%s|%h|%b---END---" --no-merges | sed 's/---END---/\n/g')

        # Helper function to sort entries by issue number and format output
        sort_entries() {
          local -n arr=$1
          if [ ${#arr[@]} -gt 0 ]; then
            printf '%s\n' "${arr[@]}" | sort -t'|' -k1 -n | cut -d'|' -f2-
          fi
        }

        # Build changelog
        CHANGELOG=""

        # Add Highlights section if any /release-note entries exist
        if [ ${#HIGHLIGHTS[@]} -gt 0 ]; then
          CHANGELOG="### âœ¨ Highlights"$'\n\n'
          for HIGHLIGHT in "${HIGHLIGHTS[@]}"; do
            CHANGELOG="${CHANGELOG}- ${HIGHLIGHT}"$'\n'
          done
          CHANGELOG="${CHANGELOG}"$'\n'
        fi

        # Add categorized sections in order: Bug Fixes, Performance & Improvements, New Features, Maintenance, Other
        if [ ${#BUGS[@]} -gt 0 ]; then
          CHANGELOG="${CHANGELOG}### ðŸ› Bug Fixes"$'\n\n'
          while IFS= read -r entry; do
            CHANGELOG="${CHANGELOG}${entry}"$'\n'
          done < <(sort_entries BUGS)
          CHANGELOG="${CHANGELOG}"$'\n'
        fi

        if [ ${#IMPROVEMENTS[@]} -gt 0 ]; then
          CHANGELOG="${CHANGELOG}### âš¡ Performance & Improvements"$'\n\n'
          while IFS= read -r entry; do
            CHANGELOG="${CHANGELOG}${entry}"$'\n'
          done < <(sort_entries IMPROVEMENTS)
          CHANGELOG="${CHANGELOG}"$'\n'
        fi

        if [ ${#FEATURES[@]} -gt 0 ]; then
          CHANGELOG="${CHANGELOG}### ðŸŽ‰ New Features"$'\n\n'
          while IFS= read -r entry; do
            CHANGELOG="${CHANGELOG}${entry}"$'\n'
          done < <(sort_entries FEATURES)
          CHANGELOG="${CHANGELOG}"$'\n'
        fi

        if [ ${#MAINTENANCE[@]} -gt 0 ]; then
          CHANGELOG="${CHANGELOG}### ðŸ”§ Maintenance"$'\n\n'
          while IFS= read -r entry; do
            CHANGELOG="${CHANGELOG}${entry}"$'\n'
          done < <(sort_entries MAINTENANCE)
          CHANGELOG="${CHANGELOG}"$'\n'
        fi

        if [ ${#OTHER[@]} -gt 0 ]; then
          CHANGELOG="${CHANGELOG}### ðŸ“¦ Other"$'\n\n'
          while IFS= read -r entry; do
            CHANGELOG="${CHANGELOG}${entry}"$'\n'
          done < <(sort_entries OTHER)
          CHANGELOG="${CHANGELOG}"$'\n'
        fi

        # If changelog is empty, use a fun message
        if [ -z "$CHANGELOG" ]; then
          CHANGELOG="So much goodness, we lost track! ðŸŽ‰"
        fi

        echo "Generated changelog:"
        echo "$CHANGELOG"

        echo "CHANGELOG<<EOF" >> $GITHUB_OUTPUT
        echo "$CHANGELOG" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
      shell: bash
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
